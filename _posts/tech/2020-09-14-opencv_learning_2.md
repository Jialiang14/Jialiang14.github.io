---

layout: post

title:opencv学习笔记

category: 技术，opencv，C++

tag: React

keyword: React

---

## opncv 读书笔记（2）

88. （接上）**数学形态学**用于分析和处理离散图像。它定义了一系列运算，用预先定义的形状元素探测图像，从而实现图像的转换。

89. **形态学滤波器腐蚀和膨胀图像** 腐蚀和膨胀是最基本的形态学运算。

90. 数学形态学中最基本的概念是**结构元素**（卷积？）形态学滤波器的应用过程就包含了用这个结构元素探测图像中每个像素的操作过程。结构元素原则上可以是任何形状，但通常是一个简单形状，并且把中心点作为远点。*自定义结构元素可用于强化或消除特殊形状。*

91. 形态学滤波器通常作用于二值图像。习惯用高像素值（白色）表示前景物体，用低像素值（黑色）表示背景物体，因此通过阈值化创建的二值图像后，要进行依次反向处理（原图像的补码）。

92. **腐蚀**就是把当前像素替换成所定义像素集合中的最小像素值；**膨胀**是腐蚀的反运算，它把当前像素替换成所定义像素集中的最大像素值。腐蚀时，如果结构元素放到某个像素位置时碰到了背景（即交集中有一个像素是黑色的），那么这个像素就变为背景；膨胀时，如果结构元素放到某个背景像素位置时，碰到了前景物体，那么这个像素就被标为白色。因此，图像腐蚀后物体尺寸会缩小（形状被腐蚀），而图像膨胀后物体会扩大。在腐蚀图像中，有些面积较小的物体（可看作背景中的”噪声“像素）会彻底消失。与之类似，膨胀后的物体会变大，而物体中一些”空隙“会被填满。

93. 使用自定义的结构元素腐蚀图像：

    ```
    // 创建7x7的mat变量，其中全部元素都为1
    cv::Mat element(7,7,CV_8U,cv::Scalar(1));
    // 用这个结构元素腐蚀图像
    cv::erode(image, eroeded, element);
    与一下操作结果一致：即在图像上反复应用同一个结构元素
    cv::erode(image, eroded, cv::Mat(), cv::Point(-1,-1), 3); // 没有cv::Mat()后的两个参数时，使用的是默认的结构元素。
    ```

    参数cv::Point(-1,-1)表示原点是矩阵的中心点（默认值），也可以定义在结构元素上的其他位置。由此得到的图像与使用7x7结构元素得到的图像是一样的。实际上，对图像腐蚀两次相当于对结构元素自身膨胀后的图像进行腐蚀。这个规则也适用于膨胀。

94. 用结构元素腐蚀前景物体可看作对图像背景部分的膨胀，也就是说：
    + 腐蚀图像相当于对其反色图像膨胀后再取反色；
    + 膨胀图像相当于对其反色图像腐蚀后再取反色。

95. 形态学滤波器应用在了二值图像上，但这些滤波器也能应用再灰度图像，甚至彩色图像上，并且方法的定义是相同的。另外，OpenCV的形态学函数支持就地处理。这意味着输入图像和输出图像可以采用同一个变量，

    ```
    cv::erode(image, image, cv::Mat());
    ```

    OpenCV会创建必须的临时图像，从而保证这种方法能正常运行。

96. **闭合**的定义是对图像先膨胀后腐蚀，白色前景物体中的小空隙已经被填满。闭合滤波器也会把邻近的物体连接起来。基本上，所有小到不能容纳完整结构元素的空隙或间隙都会被闭合滤波器消除。

97. **开启**的定义是对图像先腐蚀后膨胀。开启滤波器消除了背景中的几个小物体。所有小到不能容纳完整结构元素的物体都会被移除。

98. 这些滤波器常用于目标检测。闭合滤波器可把错误分裂成小碎片的物体连接起来，而开启滤波器可以移除因图像噪声产生的斑点。

99. 在提取图像中的连通组件前，通常要开启和闭合运算来清理图像。

100. 形态学梯度运算可以提取出图像的边缘。

     ```
     // 用3x3结构元素得到梯度图像
     cv::Mat result;
     cv::morphologyEx(image, result, cv::MORPH_GRADIENT, cv::Mat());
     ```

     得到图像中物体的轮廓（为方便观察，对图像做了反色处理）。

101. **顶帽（hat-top）**变换，它可以从图像中提取出局部的小型前景物体。可以调用黑帽变换提取出页面上的文字（作为前景物体）：

     ```
     // 使用7x7结构元素做黑帽变换
     cv::Mat element7(7,7, CV_8U, cv::Scalar(1));
     cv::morphologyEx(image, result, cv::MORPH_BLACKHAT, element7);
     ```

102. 通过计算膨胀后的图像与腐蚀后的图像之间的差距得到边缘。因为这两种转换后图像的差别主要在边缘地带，所以相减后突出边缘。**结构元素越大，检测到的边缘就越宽**。这种边缘检测运算称为**Beucher梯度**。以下两种方法也能得到类似的结果：用膨胀后的图像减去原始图像，或者用原始图像减去腐蚀后的图像，那样得到的边缘会更窄。

103. **分水岭变换**是一种流行的图像处理算法，用于快速将图像分割册灰姑娘多个同质区域。基于这样的思想：如果把图像看作一个拓扑地貌，那么同类区域就相当于陡峭边缘内相对平坦的盆地。分水岭算法通过逐步增高水位，把地貌分割成多个部分。`cv::watershed`函数。

104. **用MSER算法提取特征区域**（最大稳定外部区域算法），从图像中提取有意义的区域。创建这些区域时也使用逐步提高水位的方法，但是这次关注的是在水淹过程中的某段时间内，保持相对稳定的盆地，可以发现，这些区域对应着图像中某些物体的特殊部分。`cv::MSER` 继承自`cv::Feature2D`类。

     ```
     //基本的MSER检测器
     cv::Ptr<cv::MSER> ptrMSER = cv::MSER::create(
     											5,	// 局部检测时使用的增量值
     											200,	// 允许的最小面积
     										2000); 	// 允许的最大面积
     // 点集的容器
     std::vector<std::vector<cv::Point>> points;
     // 矩形的容器
     std::vector<cv:Rect> rects;
     // 检测MSER特征
     ptrMSER->detectRegions(image, points, rects);
     ```

     检测结果放在两个容器中，第一个区域的容器，每个区域用组成它的像素点表示；第二个是矩形的容器，每个矩形包围一个区域。

105. MSER 的原理与分水岭算法相同，即高度为 0~255，逐渐淹没图像。在图像处理技术中，通常把高于某个阈值的像素集合称为高度集。随着水位的升高，颜色较黑并且边界陡峭的区域会形成盆地 ，并且在一段时间内有相对稳定的形状（用水位表示颜色，水位高低代表了像素值的强度）。这些稳定的盆地就是 MSER。检测它们的方法是，观察每个水位连通的区域（即盆地）并测量它们的稳定性。*测量稳定性的方法是：计算区域的当前面积以及该区域原先的面积（比当前水位低一个特定值的时候），并比较这两个面积。如果相对变化达到局部最小值，就认为这个区域是 MSER。增量值将作为 cv::MSER 类构造函数的第一个参数，用以测量相对稳定性，默认值为 5。另外要注意，区域面积必须在预定义的范围内。构造函数中后面两个参数就是允许的最小和最大区域尺寸。另外必须确保 MSER 是稳定的（第四个参数），即形状的相对变化必须足够小。一个稳定区域可以属于另一个更大的区域（称为父区域）。*

106. 为了确保有效性，一个父MSER和它的子区域必须有足够大的差别，即差异限度，由`cv::MSER`类构造函数的第五个参数指定。最后两个参数都使用了默认值。（MSER允许的最大相对变化的默认值为0.25，父MSER与子区域的最小差别的默认值为0.2。）

107. 对于有父子关系的MSER，表示他们的椭圆通常比较类似。在某些情况下，可以施加一个约束条件，要求椭圆之间的差距不低于某个特定值，以免显示重复的椭圆。

## 图像滤波

108. 滤波是信号和图像处理中的一种基本操作。它的目的是选择性地提取图像中某些方面地内容，这些内容在特定应用环境下传达了重要信息。滤波可去除图像中的噪声，提取有用的视觉特征，对图像重采样。

109. 通过观察灰度分布来描述图像特征，称为**空域**。通过观察图像中灰度级的变化的频域，这种特征称为**频域**。

110. 频域分析把图像分解成从低频到高频的频率成分。*图像强度值变化慢的区域只包含低频率，而强度值变化快的区域产生高频率*。**傅里叶变换**和**余弦变换**可以清楚地显示图像地频率成分。频率分垂直频率（垂直方向的变化）和水平频率（水平方向的变化）。

111. 在频域分析框架下，**滤波器**是一种放大（也可以不改变）图像中某些频段，同时滤掉（或减弱）其他频段的算子。如，低通滤波器的作用是消除图像中的高频部分；高通滤波器刚好相反，用来i消除图像中的低频部分。*高频成分正好对应了物体边缘处的快速视觉变化。*

112. 应用一个线性滤波器相当于将内核移动到图像的每个像素上，并将每个对应像素乘以它的权重。这个运算在数学上称为**卷积**。
     $I_{out}(x,y)=\sum{i}{\sum{j}{I_{im}(x-i)(y-j)K(i,j)}}$

113. 高斯滤波器，像素对应的权重与它到中心像素之间的距离成正比。
     $G(x)=Ae^{\frac{-x^2}{\sigma^2}}$

     使用归一化系数A是为了确保高斯曲线下方的面积等于1。符号\sigma的值决定了高斯函数曲线的宽度。这个值越大，函数曲线就越扁平。

     ![不同\sigma](https://winterwindwang.github.io/assets/img/2020-09-15-opencv_gaussis.png)

114. 均值滤波器并没有消除全部高频成分。

115. 在图像上应用二维高斯滤波器，只需要现在横向线条上应用一维高斯滤波器（过滤水平方向的频率），然后在纵向线条上应用另一个一维高斯滤波器（过滤垂直方向的频率）。高斯绿泥器是一种**可分离滤波器**（二维内核可分解成两个一维滤波器）。由于可分离滤波器所用的乘法运算更少，因此它的计算速度通常比不可分离滤波器要快。`cv::sepFilter2D`普通的可分离滤波器，`cv::filter2D`函数之间应用二维内核。

116. 如果图像中一个较暗的区域中出现了一个亮点，那么用拉普拉斯运算就会使这个亮点变得更亮。因为图像中的边缘就是那些灰度发生跳变的区域，*所以拉普拉斯锐化模板在边缘检测中很有用。*一般增强技术对于陡峭的边缘和缓慢变化的边缘很难确定其边缘的位置。但此算子却可用二次微分正峰和负峰之间的过零点来确定，对孤立点或端点更为敏感，因此特别适用于以突出图像中的孤立点、鼓励线或线端点为目的的场合。同梯度算子一样，拉普拉斯算子也会增强图像中的噪声，有时用拉普拉斯算子进行边缘检测时，可将图像先进行平滑处理。

117. 图像锐化处理的作用是使灰度反差增强，从而使模糊图像变得更加清晰。图像模糊的实质就是图像受到平均运算或积分运算，因此可以对图像进行逆运算，如微分运算能够突出图像细节，使图像变得更为清晰。由于拉普拉斯是一种微分算子，它的应用可增强图像中灰度突变的区域，减弱灰度的缓慢变化区域。因此，锐化处理可选择拉普拉斯算子对原图像进行处理，产生描述灰度突变的图像，再将拉普拉斯图像与原始图像叠加而产生锐化图像。

118. 将原始图像通过拉普拉斯变换后增强了图像中灰度突变处的对比度，使图像中小的细节部分得到增强并保留了图像的背景色调，使图像的细节比原始图像更加清晰。基于拉普拉斯变换的图像增强已成为图像锐化处理的基本工具。

119. 降低图像精度的过程称为**缩减像素采样（downsampling）**,提升图像精度的过程称为**提升像素采样（upsampling）**。为尽可能保持图像质量，采用低通滤波器来实现。

120. 在小图像（即像素较少的图像）中展现精致纹理和尖锐边缘的效果不如在较高分辨率的图像中展现它们的效果好（高清电视和普通电视的差别）。图像中精致的细节对应着高频，因此需要在缩小图像之前去除它的高频成分。

121. **Nyquist-Shannon定理**，如果把图像缩小一半，那么其可见的频率带宽也将减少一半。

     ```
     cv::Mat reducedImage;  // 用于存储缩小后的图像
     cv::pyrDown(image, reducedImage); 	// 图像尺寸缩小一半
     ```

     该函数使用一个5x5的高斯滤波器，在把图像缩小一半之前先进行低通滤波。功能相反的函数有`cv::pyrUp`,它可以放大图像的尺寸。在这种提升像素采样的过程中，先在每两行和每列之间分别插入值为0的像素，然后对扩展后的图像应用同样的5x5高斯滤波器（但系数要扩大4倍）。这两个函数可用来创建图像金字塔。它是一个数据结构，由一幅图像不同尺寸的版本堆叠起来，用于高效的图像分析。

122. 先缩小一幅图像再把它放大，显然不能完全让它恢复到原始状态，因为缩小过程中丢失的信息是无法恢复的。

123. `cv::resize`是一个更通用的函数，它可以指定缩放后图像的尺寸。你只需要在调用它时指定新的尺寸，这个尺寸可用比原始图像小，也可以比原始图像大：

     ```
     cv::Mat resizedImage;		// 用于存储缩放后的图像
     cv::resize(image, resizedImage, cv::Size(image.cols/4, image.rows/4)); // 行和列均缩小为原来的1/4
     也可以指定缩放比例。在参数中提供一个空的图像实例，然后提供缩放比例：
     cv::resize(image, resizedImage, cv::Size(), 1.0/4.0. 1.0/4.0); 	// 缩小为原来的1/4
     ```

124. 按比例缩放图像后，必须进行像素插值，以便在原像素之间的位置插入新的像素值。

125. 进行插值的最基本方法是使用最近邻策略。把带生成图像的像素网格放在原图像的上方，每个新像素被赋予原图像中最近邻像素的值。

     ```
     cv::resize(reduced, newImage, cv::Size(), 3, 3, cv::INTER_NEAREST);
     // 双线性插值
     cv::resize(reduced, newImage, cv::Size(), 4, 4, cv::INTER_LINEAR);
     ```

126. 



